## 问题

给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度。

### 示例1

    输入: "(()"
    输出: 2
    解释: 最长有效括号子串为 "()"

### 示例2

    输入: ")()())"
    输出: 4
    解释: 最长有效括号子串为 "()()"

## 解题思路

此题要用栈的方法来解。

- 从左向右遍历字符串，用栈来存放字符串中 '(' 左括号的*索引*(位置)，每遇到一个 '(' 左括号，就向栈内`push`它的索引；
- 遇到 ')' 右括号，它可以匹配离它最近的一个左括号，所以让栈顶的元素出栈`pop`，此时的有效长度 = 当前的索引`i` - 元素出栈后栈顶元素的索引`top`(也有人表示为当前索引 - 出栈的索引 + 1)；
- 但是当所有的左括号都有右括号相匹配时，栈里没有元素，栈顶就无元素，无法计算，所以就做了一个特殊处理，在遍历前，先在栈里压入一个`-1`；
- 在某一索引之前的所有左右括号都能互相匹配时，此时栈里为`-1`，若该索引处为 ')' 右括号，根据算法先弹出`-1`，此时为空栈，然后压入该索引。

总结：

1. 两种索引会入栈：等待匹配的左括号索引、充当“分隔符”的右括号索引
2. 后者也要入栈的原因：当括号匹配光了，栈还需要留一个“垫底”的“参照物”

## 代码

```c++
class Solution {
public:
    int longestValidParentheses(string s)
    {
        int maxans=0;
        stack<int> stk;
        stk.push(-1);
        for(int i=0;i<s.length();i++)
        {
            if(s[i]=='(')
                stk.push(i);
            else
            {
                stk.pop();
                if(stk.empty())
                    stk.push(i);
                else
                    maxans=max(maxans,i-stk.top());
            }
        }
        return maxans;
    }
};
```
